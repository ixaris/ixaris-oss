package com.ixaris.commons.swaggergenerator.swagger;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ixaris.commons.microservices.lib.proto.CommonsMicroservicesLib.ClientInvalidRequest;
import com.ixaris.commons.microservices.lib.proto.CommonsMicroservicesLib.DefaultError;
import com.ixaris.commons.microservices.scslparser.model.ScslDefinition;
import com.ixaris.commons.microservices.web.swagger.exposed.ExposedServicesSpec;
import com.ixaris.commons.microservices.web.swagger.exposed.ScslCreateMethodFilter;
import com.ixaris.commons.microservices.web.swagger.exposed.ScslMethodFilter;
import com.ixaris.commons.misc.lib.conversion.SnakeCaseHelper;
import com.ixaris.commons.misc.lib.object.Tuple2;

import io.swagger.models.HttpMethod;
import io.swagger.models.Info;
import io.swagger.models.Model;
import io.swagger.models.Operation;
import io.swagger.models.Path;
import io.swagger.models.RefModel;
import io.swagger.models.Response;
import io.swagger.models.Scheme;
import io.swagger.models.Swagger;
import io.swagger.models.parameters.BodyParameter;
import io.swagger.models.parameters.HeaderParameter;
import io.swagger.models.parameters.PathParameter;
import io.swagger.models.parameters.RefParameter;
import io.swagger.models.properties.RefProperty;
import io.swagger.models.properties.StringProperty;

/**
 * A swagger generator using SCSL files as the source for generation.
 *
 * <p>The generation process starts by reading all the SCSL files, creating a List of {@link SwaggerOperationDescriptor}s for each method to be
 * exposed and for each method to be exposed, it is translated into a {@link Swagger} object.
 *
 * @author <a href="mailto:aldrin.seychell@ixaris.com">aldrin.seychell</a>
 */
public class SwaggerGenerator {
    
    private static final Logger LOG = LoggerFactory.getLogger(SwaggerGenerator.class);
    
    private static final String MEDIATYPE_JSON = "application/json";
    private static final String CALL_REF_HEADER_PARAM = "callRef";
    private static final String PROGRAMME_KEY_HEADER_PARAM = "programmeKey";
    private static final String AUTHORIZATION_HEADER_PRAAM = "Authorization";
    
    public static final class ApiAndWebHook {
        
        public final Swagger api;
        public final Swagger webHook;
        
        private ApiAndWebHook(final Swagger api, final Swagger webHook) {
            this.api = api;
            this.webHook = webHook;
        }
        
    }
    
    private SwaggerGenerator() {}
    
    public static ApiAndWebHook generateApiAndWebHook(final ExposedServicesSpec exposedServicesSpec,
                                                      final Info apiInfo,
                                                      final String apiHost,
                                                      final String apiBasePath,
                                                      final Info webHookInfo,
                                                      final String webHookHost,
                                                      final String webHookBasePath) {
        
        final ScslMethodFilter scslMethodFilter = exposedServicesSpec.getExposedMethodFilter();
        final ScslCreateMethodFilter createMethodFilter = exposedServicesSpec.getCreateMethodFilter();
        
        final Swagger apiSwagger = new Swagger();
        
        apiSwagger
            .host(apiHost)
            .basePath(apiBasePath)
            .scheme(Scheme.HTTP)
            .scheme(Scheme.HTTPS)
            .info(apiInfo)
            .consumes(MEDIATYPE_JSON)
            .produces(MEDIATYPE_JSON);
        
        apiSwagger.parameter(PROGRAMME_KEY_HEADER_PARAM,
            new HeaderParameter()
                .name("X-programmeKey")
                .required(true)
                .type(StringProperty.TYPE)
                .description("This identifies your tenant and programme within OPE. The typical format is `tenantId|programmeId`, for example `team-01|3749203750`."));
        apiSwagger.parameter(CALL_REF_HEADER_PARAM,
            new HeaderParameter()
                .name("X-callref")
                .required(false)
                .type(StringProperty.TYPE)
                .description("A unique call reference to provide correlation between application and system. This can be generated by your application."));
        apiSwagger.parameter(AUTHORIZATION_HEADER_PRAAM,
            new HeaderParameter()
                .name("Authorization")
                .required(true)
                .type(StringProperty.TYPE)
                .description("This is the authorisation token that you receive after logging into the API with your credentials. "
                    + "To login, you need to perform a `POST` call on `/auth/login` with your credentials."));
        
        final Swagger webHookSwagger = new Swagger();
        
        webHookSwagger
            .host(webHookHost)
            .basePath(webHookBasePath)
            .scheme(Scheme.HTTP)
            .scheme(Scheme.HTTPS)
            .info(webHookInfo)
            .consumes(MEDIATYPE_JSON)
            .produces(MEDIATYPE_JSON);
        
        webHookSwagger.parameter(PROGRAMME_KEY_HEADER_PARAM,
            new HeaderParameter()
                .name("X-programmeKey")
                .required(true)
                .type(StringProperty.TYPE)
                .description("This identifies your tenant and programme within OPE. The typical format is `tenantId|programmeId`, for example `team-01|3749203750`."));
        webHookSwagger.parameter(CALL_REF_HEADER_PARAM,
            new HeaderParameter()
                .name("X-callref")
                .required(true)
                .type(StringProperty.TYPE)
                .description("A unique call reference to provide correlation between application and system. This can be generated by your application."));
        
        final ScslSwaggerConversionContext apiContext = new ScslSwaggerConversionContext();
        final Map<String, Path> apiHttpPathToSwaggerPath = new HashMap<>();
        
        final ScslSwaggerConversionContext webHookContext = new ScslSwaggerConversionContext();
        final Map<String, Path> webHookHttpPathToSwaggerPath = new HashMap<>();
        
        for (final Tuple2<ScslDefinition, String> exposedScslEntry : exposedServicesSpec.getExposedScslFiles()) {
            
            LOG.info("Generating Swagger Definitions for SCSL: [{}] with base name [{}]", exposedScslEntry.get1(), exposedScslEntry.get2());
            
            // Extract MethodDescriptors to be generated
            final OperationAndEventDescriptors operationAndEventDescriptorsToRender = ScslSwaggerDescriptorConverter
                .generateSwaggerDescriptorsFromScsl(exposedScslEntry.get2(), exposedScslEntry.get1(), scslMethodFilter, createMethodFilter);
            
            // For each operation, convert it to swagger format and add it to the Swagger Object
            for (final SwaggerOperationDescriptor descriptor : operationAndEventDescriptorsToRender.getOperationDescriptors()) {
                final Operation operation = convertOperationDescriptorToOperation(descriptor, apiContext);
                final String httpPath = pathStartingWithSlash(descriptor.getHttpPath());
                final Path swaggerPath = apiHttpPathToSwaggerPath.computeIfAbsent(httpPath, s -> new Path());
                operation.addTag(SnakeCaseHelper.snakeToHuman(exposedScslEntry.get2()));
                setPathMethod(descriptor, swaggerPath, operation);
                
                if (apiSwagger.getPath(httpPath) != null
                    && apiSwagger.getPath(httpPath).getOperationMap().containsKey(descriptor.getHttpMethod())) {
                    throw new IllegalStateException("Path conflict encountered when generating swagger. This might be an issue with selecting the friendly names to expose. Method: "
                        + descriptor);
                }
                apiSwagger.path(httpPath, swaggerPath);
            }
            
            // For each event, convert it to swagger format and add it to the Swagger Object
            for (final SwaggerEventDescriptor descriptor : operationAndEventDescriptorsToRender.getEventDescriptors()) {
                final Operation operation = convertEventDescriptorToOperation(descriptor, apiContext);
                final String httpPath = pathStartingWithSlash(descriptor.getHttpPath());
                final Path swaggerPath = webHookHttpPathToSwaggerPath.computeIfAbsent(httpPath, s -> new Path());
                operation.addTag(SnakeCaseHelper.snakeToHuman(exposedScslEntry.get2()));
                swaggerPath.post(operation);
                
                if (webHookSwagger.getPath(httpPath) != null && webHookSwagger.getPath(httpPath).getOperationMap().containsKey(HttpMethod.POST)) {
                    throw new IllegalStateException("Path conflict encountered when generating swagger.  This might be an issue with selecting the friendly names to expose. Method: "
                        + descriptor);
                }
                webHookSwagger.path(httpPath, swaggerPath);
            }
        }
        
        addModelDefinitions(apiSwagger, apiContext);
        addModelDefinitions(webHookSwagger, webHookContext);
        
        return new ApiAndWebHook(apiSwagger, webHookSwagger);
    }
    
    private static void addModelDefinitions(final Swagger swagger, final ScslSwaggerConversionContext context) {
        // in the future we might want to do this check earlier and modify the clashed model references, e.g. prefix
        // with service name
        // or in swagger 3 we may be able to namespace them with the service package
        final Map<String, String> uniqueModelRefToFullName = new HashMap<>();
        for (final Entry<String, Model> model : context.getFullNameToModelMap().entrySet()) {
            final String existingFullName = uniqueModelRefToFullName.put(model.getValue().getReference(), model.getKey());
            if (existingFullName != null) {
                LOG.warn("Model ref clash between [{}] and [{}]", existingFullName, model.getKey());
            }
            swagger.addDefinition(model.getValue().getReference(), model.getValue());
        }
    }
    
    private static Operation convertOperationDescriptorToOperation(final SwaggerOperationDescriptor descriptor,
                                                                   final ScslSwaggerConversionContext context) {
        final Operation operation = new Operation();
        operation.operationId(descriptor.getOperationId());
        if (descriptor.getDescription() != null && !descriptor.getDescription().isEmpty()) {
            operation.description(descriptor.getDescription());
        }
        
        // Add Path Parameters
        final List<PathParameter> pathParams = descriptor.getPathParams();
        for (final PathParameter pathParam : pathParams) {
            operation.addParameter(pathParam);
        }
        
        operation.addParameter(new RefParameter(CALL_REF_HEADER_PARAM));
        operation.addParameter(new RefParameter(PROGRAMME_KEY_HEADER_PARAM));
        
        if (descriptor.isSecured()) {
            operation.addParameter(new RefParameter(AUTHORIZATION_HEADER_PRAAM));
        }
        
        final Class<?> requestType = descriptor.getRequestType();
        if (requestType != null) {
            constructRequestSchema(context, operation, requestType, "request");
        }
        
        final Class<?> responseType = descriptor.getResponseType();
        if (responseType != null) {
            constructSuccessfulResponseSchema(descriptor, context, operation, responseType);
        } else {
            constructNoContentSchema(operation);
        }
        
        final Class<?> conflictType = descriptor.getConflictType();
        if (conflictType != null) {
            constructConflictSchema(context, operation, conflictType);
        }
        
        constructInvalidRequestSchema(context, operation);
        
        constructDefaultErrorSchema(context, operation);
        
        return operation;
    }
    
    private static Operation convertEventDescriptorToOperation(final SwaggerEventDescriptor descriptor,
                                                               final ScslSwaggerConversionContext context) {
        final Operation operation = new Operation();
        operation.operationId(descriptor.getEventId());
        if (descriptor.getDescription() != null && !descriptor.getDescription().isEmpty()) {
            operation.description(descriptor.getDescription());
        }
        
        operation.addParameter(new RefParameter(CALL_REF_HEADER_PARAM));
        operation.addParameter(new RefParameter(PROGRAMME_KEY_HEADER_PARAM));
        
        final Class<?> eventType = descriptor.getEventType();
        if (eventType != null) {
            constructRequestSchema(context, operation, eventType, "event");
        }
        
        constructNoContentSchema(operation);
        
        constructDefaultErrorSchema(context, operation);
        
        return operation;
    }
    
    private static void constructRequestSchema(final ScslSwaggerConversionContext context,
                                               final Operation operation,
                                               final Class<?> requestType,
                                               final String requestBodyName) {
        final Model model = SwaggerModelConverter.getOrCreateModelFromClass(context, requestType);
        
        final BodyParameter requestBody = new BodyParameter();
        requestBody.name(requestBodyName);
        requestBody.setRequired(true);
        
        final RefModel refModel = new RefModel();
        refModel.set$ref(model.getReference());
        requestBody.schema(refModel);
        
        operation.addParameter(requestBody);
    }
    
    private static void constructConflictSchema(final ScslSwaggerConversionContext context,
                                                final Operation operation,
                                                final Class<?> conflictType) {
        final Model responseModel = SwaggerModelConverter.getOrCreateModelFromClass(context, conflictType);
        
        final RefProperty property = new RefProperty();
        property.asDefault(responseModel.getReference());
        
        final Response response = new Response();
        response.schema(property);
        response.description("Conflict");
        operation.addResponse("409", response);
    }
    
    private static void constructNoContentSchema(final Operation operation) {
        final Response response = new Response();
        response.description("Success - No Content");
        operation.addResponse("204", response);
    }
    
    private static void constructInvalidRequestSchema(final ScslSwaggerConversionContext context, final Operation operation) {
        final Model responseModel400 = SwaggerModelConverter.getOrCreateModelFromClass(context, ClientInvalidRequest.class);
        final Response response400 = new Response();
        response400.schema(new RefProperty().asDefault(responseModel400.getReference()));
        response400.description("Invalid Request");
        operation.addResponse("400", response400);
    }
    
    private static void constructDefaultErrorSchema(final ScslSwaggerConversionContext context, final Operation operation) {
        final Model defaultErrorModel = SwaggerModelConverter.getOrCreateModelFromClass(context, DefaultError.class);
        final Response defaultResponse = new Response();
        defaultResponse.schema(new RefProperty().asDefault(defaultErrorModel.getReference()));
        defaultResponse.description("Default Error");
        operation.addResponse("default", defaultResponse);
    }
    
    private static void constructSuccessfulResponseSchema(final SwaggerOperationDescriptor descriptor,
                                                          final ScslSwaggerConversionContext context,
                                                          final Operation operation,
                                                          final Class<?> responseType) {
        final Model responseModel = SwaggerModelConverter.getOrCreateModelFromClass(context, responseType);
        
        final Response response = new Response();
        response.schema(new RefProperty().asDefault(responseModel.getReference()));
        response.description("Success");
        operation.addResponse("200", response);
        
        if (!"get".equalsIgnoreCase(descriptor.getMethodName())) {
            final Response response201 = new Response();
            response201.schema(new RefProperty().asDefault(responseModel.getReference()));
            response201.description("Created");
            operation.addResponse("201", response201);
        }
    }
    
    private static String pathStartingWithSlash(final String httpPath) {
        return httpPath.startsWith("/") ? httpPath : '/' + httpPath;
    }
    
    private static void setPathMethod(final SwaggerOperationDescriptor descriptor, final Path path, final Operation operation) {
        switch (descriptor.getHttpMethod()) {
            case GET:
                path.get(operation);
                break;
            case POST:
                path.post(operation);
                break;
            case PATCH:
                path.patch(operation);
                break;
            case PUT:
                path.put(operation);
                break;
            case DELETE:
                path.delete(operation);
                break;
            case OPTIONS:
                path.options(operation);
                break;
            case HEAD:
                path.head(operation);
                break;
            default:
                throw new UnsupportedOperationException("HTTP method [" + descriptor.getOperationId() + "] is unmapped");
        }
    }
    
}
