package com.ixaris.commons.microservices.scsl2openapi.lib;

import static com.ixaris.commons.misc.lib.object.Tuple.tuple;

import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ixaris.commons.microservices.lib.proto.CommonsMicroservicesLib.ClientInvalidRequest;
import com.ixaris.commons.microservices.lib.proto.CommonsMicroservicesLib.DefaultError;
import com.ixaris.commons.microservices.scslparser.model.ScslDefinition;
import com.ixaris.commons.microservices.web.swagger.exposed.ExposedServicesSpec;
import com.ixaris.commons.microservices.web.swagger.exposed.ScslCreateMethodFilter;
import com.ixaris.commons.microservices.web.swagger.exposed.ScslMethodFilter;
import com.ixaris.commons.misc.lib.conversion.SnakeCaseHelper;
import com.ixaris.commons.misc.lib.object.Tuple2;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.Operation;
import io.swagger.v3.oas.models.PathItem;
import io.swagger.v3.oas.models.PathItem.HttpMethod;
import io.swagger.v3.oas.models.Paths;
import io.swagger.v3.oas.models.headers.Header;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.media.Content;
import io.swagger.v3.oas.models.media.MediaType;
import io.swagger.v3.oas.models.media.Schema;
import io.swagger.v3.oas.models.media.StringSchema;
import io.swagger.v3.oas.models.parameters.HeaderParameter;
import io.swagger.v3.oas.models.parameters.Parameter;
import io.swagger.v3.oas.models.parameters.PathParameter;
import io.swagger.v3.oas.models.parameters.RequestBody;
import io.swagger.v3.oas.models.responses.ApiResponse;
import io.swagger.v3.oas.models.responses.ApiResponses;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.oas.models.security.SecurityScheme.In;
import io.swagger.v3.oas.models.security.SecurityScheme.Type;
import io.swagger.v3.oas.models.servers.Server;

/**
 * A swagger generator using SCSL files as the source for generation.
 *
 * <p>The generation process starts by reading all the SCSL files, creating a List of {@link OpenAPIOperationDescriptor}s for each method to be
 * exposed and for each method to be exposed, it is translated into an {@link OpenAPI} object.
 *
 * @author <a href="mailto:aldrin.seychell@ixaris.com">aldrin.seychell</a>
 */
public class OpenAPIGenerator {
    
    private static final Logger LOG = LoggerFactory.getLogger(OpenAPIGenerator.class);
    
    private static final String MEDIATYPE_JSON = "application/json";
    
    public static final String AUTHORIZATION_HEADER = "authorization";
    public static final String CALL_REF_HEADER = "call-ref";
    private static final String CREATE_ID_HEADER = "create-id";
    
    private static final String SECURED = "secured";
    
    private static final Parameter CALL_REF_REQUEST_HEADER = new Parameter();
    private static final Header CREATE_ID_RESPONSE_HEADER = new Header();
    
    private static final SecurityRequirement SECURITY = new SecurityRequirement();
    
    static {
        CALL_REF_REQUEST_HEADER.set$ref(CALL_REF_HEADER);
        CREATE_ID_RESPONSE_HEADER.set$ref(CREATE_ID_HEADER);
        SECURITY.addList(SECURED);
    }
    
    public static final class ApiAndWebHook {
        
        public final OpenAPI api;
        public final OpenAPI webHook;
        
        private ApiAndWebHook(final OpenAPI api, final OpenAPI webHook) {
            this.api = api;
            this.webHook = webHook;
        }
        
    }
    
    private OpenAPIGenerator() {}
    
    public static ApiAndWebHook generateApiAndWebHook(final ExposedServicesSpec exposedServicesSpec, final Info apiInfo, final Info webHookInfo) {
        
        final boolean exposeSpis = exposedServicesSpec.isExposeSpis();
        final ScslMethodFilter scslMethodFilter = exposedServicesSpec.getExposedMethodFilter();
        final ScslCreateMethodFilter createMethodFilter = exposedServicesSpec.getCreateMethodFilter();
        
        final HeaderParameter callRefHeader = new HeaderParameter();
        callRefHeader
            .name(CALL_REF_HEADER)
            .required(false)
            .style(Parameter.StyleEnum.SIMPLE)
            .explode(false)
            .schema(new StringSchema())
            .description("A call reference generated by the caller and unique to the caller to provide correlation between the caller and system");
        
        final Header createIdHeader = new Header();
        createIdHeader
            .required(true)
            .style(Header.StyleEnum.SIMPLE)
            .explode(false)
            .schema(new StringSchema())
            .description("The generated id for the call");
        
        final SecurityScheme security = new SecurityScheme();
        security.setType(Type.APIKEY);
        security.setName(AUTHORIZATION_HEADER);
        security.in(In.HEADER);
        
        final Components apiComponents = new Components()
            .extensions(new HashMap<>())
            .addParameters(CALL_REF_HEADER, callRefHeader)
            .addHeaders(CREATE_ID_HEADER, createIdHeader)
            .addSecuritySchemes(SECURED, security);
        
        final Components webHookComponents = new Components()
            .extensions(new HashMap<>())
            .addParameters(CALL_REF_HEADER, callRefHeader)
            .addSecuritySchemes(SECURED, security);
        
        exposedServicesSpec
            .getHeaders()
            .forEach((k, v) -> {
                final HeaderParameter header = new HeaderParameter();
                header
                    .name(v)
                    .required(true)
                    .style(Parameter.StyleEnum.SIMPLE)
                    .explode(false)
                    .schema(new StringSchema());
                apiComponents.addParameters(k, header);
                webHookComponents.addParameters(k, header);
            });
        
        exposedServicesSpec
            .getSecuredHeaders()
            .forEach((k, v) -> {
                final HeaderParameter header = new HeaderParameter();
                header
                    .name(v)
                    .required(true)
                    .style(Parameter.StyleEnum.SIMPLE)
                    .explode(false)
                    .schema(new StringSchema());
                apiComponents.addParameters(k, header);
                webHookComponents.addParameters(k, header);
            });
        
        final OpenAPI api = new OpenAPI()
            .info(apiInfo)
            .addServersItem(new Server().url("/"))
            .components(apiComponents)
            .paths(new Paths());
        
        final OpenAPI webHook = new OpenAPI()
            .info(webHookInfo)
            .addServersItem(new Server().url("/"))
            .components(webHookComponents)
            .paths(new Paths());
        
        final SchemaNameProcessingContext nameContext = new SchemaNameProcessingContext();
        final Set<Tuple2<OperationAndEventDescriptors, String>> services = new LinkedHashSet<>();
        
        for (final Tuple2<ScslDefinition, String> exposedScslEntry : exposedServicesSpec.getExposedScslFiles()) {
            
            if (!exposeSpis && exposedScslEntry.get1().isSpi()) {
                throw new IllegalStateException("SPIs not exposed but found SPI contract :" + exposedScslEntry.get2());
            }
            
            LOG.info("Generating Swagger Definitions for SCSL: [{}] with base name [{}]", exposedScslEntry.get1(), exposedScslEntry.get2());
            
            // Extract MethodDescriptors to be generated
            final OperationAndEventDescriptors descriptorsToRender = ScslOpenAPIDescriptorConverter
                .generateSwaggerDescriptorsFromScsl(exposedScslEntry.get2(), exposedScslEntry.get1(), scslMethodFilter, createMethodFilter);
            services.add(tuple(descriptorsToRender, exposedScslEntry.get2()));
            
            // For each operation, extract schema
            for (final OpenAPIOperationDescriptor opDescriptor : descriptorsToRender.getOperationDescriptors()) {
                final Class<?> requestType = opDescriptor.getRequestType();
                if (requestType != null) {
                    OpenAPISchemaConverter.processClass(nameContext, requestType);
                }
                
                final Class<?> responseType = opDescriptor.getResponseType();
                if (responseType != null) {
                    OpenAPISchemaConverter.processClass(nameContext, responseType);
                }
                
                final Class<?> conflictType = opDescriptor.getConflictType();
                if (conflictType != null) {
                    OpenAPISchemaConverter.processClass(nameContext, conflictType);
                }
            }
            
            // For each event, convert it to swagger format and add it to the Swagger Object
            for (final OpenAPIEventDescriptor evDescriptor : descriptorsToRender.getEventDescriptors()) {
                final Class<?> eventType = evDescriptor.getEventType();
                if (eventType != null) {
                    OpenAPISchemaConverter.processClass(nameContext, eventType);
                }
            }
        }
        
        // dedup schema names
        final Map<String, String> fullNameToName = nameContext.dedup();
        
        final SchemaProcessingContext apiContext = new SchemaProcessingContext(fullNameToName);
        final Map<String, PathItem> apiPathToSwaggerPath = new HashMap<>();
        final SchemaProcessingContext webHookContext = new SchemaProcessingContext(fullNameToName);
        final Map<String, PathItem> webHookPathToSwaggerPath = new HashMap<>();
        
        for (final Tuple2<OperationAndEventDescriptors, String> service : services) {
            // For each operation, convert it to swagger format and add it to the Swagger Object
            for (final OpenAPIOperationDescriptor descriptor : service.get1().getOperationDescriptors()) {
                final Operation operation = convertOperationDescriptorToOperation(descriptor, apiContext, exposedServicesSpec);
                final String httpPath = pathStartingWithSlash(descriptor.getHttpPath());
                final PathItem swaggerPath = apiPathToSwaggerPath.computeIfAbsent(httpPath, s -> new PathItem());
                operation.addTagsItem(SnakeCaseHelper.snakeToHuman(service.get2()));
                setPathMethod(descriptor, swaggerPath, operation);
                
                if (api.getPaths().get(httpPath) != null && api.getPaths().get(httpPath).readOperationsMap().containsKey(descriptor.getHttpMethod())) {
                    throw new IllegalStateException(
                        "Path conflict encountered when generating swagger. This might be an issue with selecting the friendly names to expose. Method: " + descriptor);
                }
                api.path(httpPath, swaggerPath);
            }
            
            // For each event, convert it to swagger format and add it to the Swagger Object
            for (final OpenAPIEventDescriptor descriptor : service.get1().getEventDescriptors()) {
                final Operation operation = convertEventDescriptorToOperation(descriptor, webHookContext, exposedServicesSpec);
                final String httpPath = pathStartingWithSlash(descriptor.getHttpPath());
                final PathItem swaggerPath = webHookPathToSwaggerPath.computeIfAbsent(httpPath, s -> new PathItem());
                operation.addTagsItem(SnakeCaseHelper.snakeToHuman(service.get2()));
                swaggerPath.post(operation);
                
                if (webHook.getPaths().get(httpPath) != null && webHook.getPaths().get(httpPath).readOperationsMap().containsKey(HttpMethod.POST)) {
                    throw new IllegalStateException(
                        "Path conflict encountered when generating swagger.  This might be an issue with selecting the friendly names to expose. Method: " + descriptor);
                }
                webHook.path(httpPath, swaggerPath);
            }
        }
        
        addModelDefinitions(api, apiContext);
        addModelDefinitions(webHook, webHookContext);
        
        return new ApiAndWebHook(api, webHook);
    }
    
    private static void addModelDefinitions(final OpenAPI api, final SchemaProcessingContext context) {
        // in the future we might want to do this check earlier and modify the clashed model references, e.g. prefix
        // with service name
        // or in swagger 3 we may be able to namespace them with the service package
        final Map<String, String> uniqueModelRefToFullName = new HashMap<>();
        for (final Entry<String, Schema<?>> entry : context.entrySet()) {
            final String name = entry.getKey();
            final Schema schema = entry.getValue();
            final String existingName = uniqueModelRefToFullName.put(schema.getName(), name);
            if (existingName != null) {
                throw new IllegalStateException("Model ref clash between [" + existingName + "] and [" + name + "]");
            }
            api.getComponents().addSchemas(schema.getName(), schema);
        }
    }
    
    private static Operation convertOperationDescriptorToOperation(final OpenAPIOperationDescriptor descriptor,
                                                                   final SchemaProcessingContext context,
                                                                   final ExposedServicesSpec exposedServicesSpec) {
        final Operation operation = new Operation().responses(new ApiResponses());
        operation.operationId(descriptor.getOperationId());
        if (descriptor.getDescription() != null && !descriptor.getDescription().isEmpty()) {
            operation.description(descriptor.getDescription());
        }
        
        // Add Path Parameters
        final List<PathParameter> pathParams = descriptor.getPathParams();
        for (final PathParameter pathParam : pathParams) {
            operation.addParametersItem(pathParam);
        }
        
        operation.addParametersItem(CALL_REF_REQUEST_HEADER);
        exposedServicesSpec
            .getHeaders()
            .forEach((k, v) -> {
                final Parameter param = new Parameter();
                param.set$ref(k);
                operation.addParametersItem(param);
            });
        
        if (descriptor.isSecured()) {
            operation.security(Collections.singletonList(SECURITY));
            exposedServicesSpec
                .getSecuredHeaders()
                .forEach((k, v) -> {
                    final Parameter param = new Parameter();
                    param.set$ref(k);
                    operation.addParametersItem(param);
                });
        }
        
        final Class<?> requestType = descriptor.getRequestType();
        if (requestType != null) {
            constructRequestSchema(context, operation, requestType);
        }
        
        final Class<?> responseType = descriptor.getResponseType();
        if (responseType != null) {
            constructSuccessfulResponseSchema(context, operation, responseType, descriptor.isCreate());
        } else {
            constructNoContentSchema(operation);
        }
        
        final Class<?> conflictType = descriptor.getConflictType();
        if (conflictType != null) {
            constructConflictSchema(context, operation, conflictType);
        }
        
        constructDefaultClientInvalidRequestSchema(context, operation);
        constructDefaultErrorSchema(context, operation);
        
        return operation;
    }
    
    private static Operation convertEventDescriptorToOperation(final OpenAPIEventDescriptor descriptor,
                                                               final SchemaProcessingContext context,
                                                               final ExposedServicesSpec exposedServicesSpec) {
        final Operation operation = new Operation().responses(new ApiResponses());
        operation.operationId(descriptor.getEventId());
        if (descriptor.getDescription() != null && !descriptor.getDescription().isEmpty()) {
            operation.description(descriptor.getDescription());
        }
        
        operation.addParametersItem(CALL_REF_REQUEST_HEADER);
        exposedServicesSpec
            .getHeaders()
            .forEach((k, v) -> {
                final Parameter param = new Parameter();
                param.set$ref(k);
                operation.addParametersItem(param);
            });
        operation.security(Collections.singletonList(SECURITY));
        exposedServicesSpec
            .getSecuredHeaders()
            .forEach((k, v) -> {
                final Parameter param = new Parameter();
                param.set$ref(k);
                operation.addParametersItem(param);
            });
        
        final Class<?> eventType = descriptor.getEventType();
        if (eventType != null) {
            constructRequestSchema(context, operation, eventType);
        }
        
        constructNoContentSchema(operation);
        
        constructDefaultErrorSchema(context, operation);
        
        return operation;
    }
    
    private static void constructRequestSchema(final SchemaProcessingContext context, final Operation operation, final Class<?> requestType) {
        final Schema<?> schema = OpenAPISchemaConverter.processClass(context, requestType);
        
        operation.setRequestBody(new RequestBody()
            .required(true)
            .content(new Content().addMediaType(MEDIATYPE_JSON, new MediaType().schema(new Schema().$ref(schema.getName())))));
    }
    
    private static void constructConflictSchema(final SchemaProcessingContext context, final Operation operation, final Class<?> conflictType) {
        final Schema<?> schema = OpenAPISchemaConverter.processClass(context, conflictType);
        
        operation
            .getResponses()
            .addApiResponse("409",
                new ApiResponse()
                    .description("Conflict")
                    .content(new Content().addMediaType(MEDIATYPE_JSON, new MediaType().schema(new Schema().$ref(schema.getName())))));
    }
    
    private static void constructNoContentSchema(final Operation operation) {
        operation.getResponses().addApiResponse("204", new ApiResponse().description("Success - No Content"));
    }
    
    private static void constructDefaultClientInvalidRequestSchema(final SchemaProcessingContext context, final Operation operation) {
        final Schema<?> schema = OpenAPISchemaConverter.processClass(context, ClientInvalidRequest.class);
        operation
            .getResponses()
            .addApiResponse("400",
                new ApiResponse()
                    .description("Invalid Request")
                    .content(new Content().addMediaType(MEDIATYPE_JSON, new MediaType().schema(new Schema().$ref(schema.getName())))));
    }
    
    private static void constructDefaultErrorSchema(final SchemaProcessingContext context, final Operation operation) {
        final Schema<?> schema = OpenAPISchemaConverter.processClass(context, DefaultError.class);
        operation
            .getResponses()
            .addApiResponse("default",
                new ApiResponse()
                    .description("Error")
                    .content(new Content().addMediaType(MEDIATYPE_JSON, new MediaType().schema(new Schema().$ref(schema.getName())))));
    }
    
    private static void constructSuccessfulResponseSchema(final SchemaProcessingContext context,
                                                          final Operation operation,
                                                          final Class<?> responseType,
                                                          final boolean create) {
        final Schema<?> schema = OpenAPISchemaConverter.processClass(context, responseType);
        
        final ApiResponse response = new ApiResponse()
            .description("Success")
            .content(new Content().addMediaType(MEDIATYPE_JSON, new MediaType().schema(new Schema().$ref(schema.getName()))));
        
        if (create) {
            response.addHeaderObject(CREATE_ID_HEADER, CREATE_ID_RESPONSE_HEADER);
        }
        
        operation.getResponses().addApiResponse("200", response);
    }
    
    private static String pathStartingWithSlash(final String httpPath) {
        return httpPath.startsWith("/") ? httpPath : '/' + httpPath;
    }
    
    private static void setPathMethod(final OpenAPIOperationDescriptor descriptor, final PathItem path, final Operation operation) {
        switch (descriptor.getHttpMethod()) {
            case GET:
                path.get(operation);
                break;
            case POST:
                path.post(operation);
                break;
            case PATCH:
                path.patch(operation);
                break;
            case PUT:
                path.put(operation);
                break;
            case DELETE:
                path.delete(operation);
                break;
            case OPTIONS:
                path.options(operation);
                break;
            case HEAD:
                path.head(operation);
                break;
            default:
                throw new UnsupportedOperationException("HTTP method [" + descriptor.getOperationId() + "] is unmapped");
        }
    }
    
}
